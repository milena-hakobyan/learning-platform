package com.example.tasks;

import com.example.model.ActivityLog;
import com.example.model.Role;
import com.example.model.User;
import com.example.repository.JpaActivityLogRepository;
import com.example.repository.JpaUserRepository;
import jakarta.persistence.EntityExistsException;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.PersistenceException;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.test.context.TestPropertySource;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
@TestPropertySource(locations = "classpath:application-local.properties")
public class ActivityLogLifecycleTest {

    @Autowired
    private JpaUserRepository userRepo;

    @Autowired
    private JpaActivityLogRepository activityLogRepo;

    @PersistenceContext
    private EntityManager entityManager;

    private User createUser() {
        User user = new User();
        user.setUserName("janedoe");
        user.setFirstName("Jane");
        user.setLastName("Doe");
        user.setEmail("janedoe@example.com");
        user.setRole(Role.INSTRUCTOR);
        user.setPassword("password123");
        user.setLastLogin(LocalDateTime.now());

        return user;
    }


    /*
        1. Select one of the One-To-Many relationships in your domain.
            I chose the User-ActivityLog one-to-many relationship, where User is the parent and log is the child.
        2. Enable JPA query logging for tests to see which queries are getting generated by the JPA
            In the local-properties.
    */


    /*
        3. Save Parent without ID using repository.save(), entityManager.persist(), entityManager.merge(). Compare the results.
    */


    @Test
    void saveActivityLog_withoutId_usingPersist() {
        User user = createUser();

        entityManager.persist(user);
        entityManager.flush();

        assertNotNull(user.getId(), "Saved User ID should be generated and not null");

    }

    @Test
    void saveActivityLog_withoutId_usingMerge() {
        User user = createUser();

        user = entityManager.merge(user);
        entityManager.flush();

        assertNotNull(user.getId(), "Saved User ID should be generated and not null");

    }


    @Test
    void saveActivityLog_withoutId_usingRepo() {
        User user = createUser();

        userRepo.save(user);

        assertNotNull(user.getId(), "Saved User ID should be generated and not null");

    }


    /*
      4. Save Parent with an initialized ID using repository.save(), entityManager.persist(), entityManager.merge().
    */

    @Test
    void saveUser_withId_usingRepo_shouldThrowException() {
        User user = createUser();
        user.setId(5L);

        assertThrows(PersistenceException.class, () -> {
            entityManager.persist(user);
            entityManager.flush();
        });
    }

    @Test
    void saveUser_withId_usingPersist_shouldThrowException() {
        User user = createUser();
        user.setId(5L);

        assertThrows(PersistenceException.class, () -> {
            entityManager.persist(user);
            entityManager.flush(); // forces DB constraint check
        });
    }

    @Test
    void saveUser_withId_usingMerge_shouldThrow() {
        User user = createUser();
        user.setId(5L);

        assertThrows(PersistenceException.class, () -> {
            entityManager.merge(user);
            entityManager.flush();
        });
    }

    /*
        5. Insert Parent with some ID to the database. Save another Parent with the same ID using repository.save(), entityManager.persist(), entityManager.merge()
     */

    @Test
    void saveUser_withExistingId_usingRepositorySave_shouldUpdateExistingUser() {
        User user = createUser();

        userRepo.saveAndFlush(user);
        Long usedId = user.getId();

        User conflictingUser = new User();
        conflictingUser.setId(usedId);//resuing the same id
        conflictingUser.setUserName("updatedUser");
        conflictingUser.setEmail("updated@example.com");
        conflictingUser.setRole(Role.STUDENT);

        userRepo.saveAndFlush(conflictingUser);

        User updatedUser = userRepo.findById(usedId).orElseThrow();

        assertEquals("updatedUser", updatedUser.getUserName());
        assertEquals("updated@example.com", updatedUser.getEmail());
        assertEquals(Role.STUDENT, updatedUser.getRole());
    }


    @Test
    void saveUser_withExistingId_usingEntityManagerPersist_shouldThrowException() {
        User user = createUser();

        entityManager.persist(user);
        entityManager.flush();

        Long usedId = user.getId();

        User conflictingUser = new User();
        conflictingUser.setId(usedId); // force same ID
        conflictingUser.setUserName("duplicate");
        conflictingUser.setFirstName("Dup");
        conflictingUser.setLastName("User");
        conflictingUser.setEmail("duplicate@example.com");
        conflictingUser.setRole(Role.INSTRUCTOR);
        conflictingUser.setPassword("dupPassword123");
        conflictingUser.setLastLogin(LocalDateTime.now());
        conflictingUser.setActive(true);

        assertThrows(EntityExistsException.class, () -> {
            entityManager.persist(conflictingUser);
            entityManager.flush();
        });
    }

    @Test
    void saveUser_withExistingId_usingEntityManagerMerge_shouldUpdateExistingUser() {
        User user = createUser();

        entityManager.persist(user);
        entityManager.flush();

        Long usedId = user.getId();

        User conflictingUser = new User();
        conflictingUser.setId(usedId); // reuse the same ID
        conflictingUser.setUserName("updatedUser");
        conflictingUser.setEmail("updated@example.com");
        conflictingUser.setRole(Role.STUDENT);
        conflictingUser.setActive(false);

        entityManager.merge(conflictingUser);
        entityManager.flush();

        User updatedUser = entityManager.find(User.class, usedId);

        assertEquals("updatedUser", updatedUser.getUserName());
        assertEquals("updated@example.com", updatedUser.getEmail());
        assertEquals(Role.STUDENT, updatedUser.getRole());
        assertFalse(updatedUser.isActive());
    }

    /*
        6. Save Parent with Children, which are not present in the database - using the same 3 approaches
     */

    @Test
    void saveUserWithNewActivityLogs_usingRepositorySave_shouldPersistAll() {
        User user = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");

        user.addActivityLog(log1);
        user.addActivityLog(log2);

        User savedUser = userRepo.save(user);

        assertNotNull(savedUser.getId());
        assertEquals(2, savedUser.getActivityLogs().size());

        savedUser.getActivityLogs().forEach(log -> {
            assertNotNull(log.getId());
        });
    }

    @Test
    void saveUserWithNewActivityLogs_usingEntityManagerPersist_shouldPersistAll() {
        User user = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");

        user.addActivityLog(log1);
        user.addActivityLog(log2);

        entityManager.persist(user);
        entityManager.flush();

        User persistedUser = entityManager.find(User.class, user.getId());

        assertNotNull(persistedUser.getId());
        assertEquals(2, persistedUser.getActivityLogs().size());

        persistedUser.getActivityLogs().forEach(log -> {
            assertNotNull(log.getId());
        });
    }

    @Test
    void saveUserWithNewActivityLogs_usingEntityManagerMerge_shouldPersistAll() {
        User userA = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");

        userA.addActivityLog(log1);
        userA.addActivityLog(log2);

        User mergedUser = entityManager.merge(userA);
        entityManager.flush();

        User retrievedUser = entityManager.find(User.class, mergedUser.getId());

        assertNotNull(retrievedUser.getId());
        assertEquals(2, retrievedUser.getActivityLogs().size());

        retrievedUser.getActivityLogs().forEach(log -> {
            assertNotNull(log.getId());
        });
    }

    /*
        7. Save Parent with Children, which are already present in the database - using the same 3 approaches
     */
    @Test
    void reassignActivityLogsFromOneUserToAnother_usingRepositorySave_shouldUpdateOwnership() {
        User userA = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");
        log1.setUser(userA);

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");
        log2.setUser(userA);

        userA.addActivityLog(log1);
        userA.addActivityLog(log2);

        userA = userRepo.saveAndFlush(userA);

        Long log1Id = userA.getActivityLogs().get(0).getId();
        Long log2Id = userA.getActivityLogs().get(1).getId();
        assertNotNull(log1Id);
        assertNotNull(log2Id);

        User userB = new User();
        userB.setUserName("userB");
        userB.setFirstName("User");
        userB.setLastName("B");
        userB.setEmail("userB@example.com");
        userB.setRole(Role.STUDENT);
        userB.setPassword("passwordB");
        userB.setLastLogin(LocalDateTime.now());

        // Reassign ActivityLogs from userA to userB
        // Fetch logs from DB to simulate detached entities (optional)
        ActivityLog existingLog1 = activityLogRepo.findById(log1Id).orElseThrow();
        ActivityLog existingLog2 = activityLogRepo.findById(log2Id).orElseThrow();

        existingLog1.setUser(userB);
        existingLog2.setUser(userB);

        userB.addActivityLog(existingLog1);
        userB.addActivityLog(existingLog2);

        //  Save User B with reassigned logs
        userB = userRepo.saveAndFlush(userB);

        // Verify logs now belong to userB
        ActivityLog updatedLog1 = activityLogRepo.findById(log1Id).orElseThrow();
        ActivityLog updatedLog2 = activityLogRepo.findById(log2Id).orElseThrow();

        assertEquals(userB.getId(), updatedLog1.getUser().getId());
        assertEquals(userB.getId(), updatedLog2.getUser().getId());

        // Also check userB's logs collection
        assertEquals(2, userB.getActivityLogs().size());
    }

    @Test
    void reassignActivityLogsFromOneUserToAnother_usingEntityManagerPersist_shouldUpdateOwnership() {
        User userA = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");
        log1.setUser(userA);

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");
        log2.setUser(userA);

        userA.addActivityLog(log1);
        userA.addActivityLog(log2);

        userA = userRepo.saveAndFlush(userA);

        Long log1Id = userA.getActivityLogs().get(0).getId();
        Long log2Id = userA.getActivityLogs().get(1).getId();

        // Step 2: Create new User B
        User userB = new User();
        userB.setUserName("userB");
        userB.setFirstName("User");
        userB.setLastName("B");
        userB.setEmail("userB@example.com");
        userB.setRole(Role.STUDENT);
        userB.setPassword("passwordB");
        userB.setLastLogin(LocalDateTime.now());

        ActivityLog existingLog1 = activityLogRepo.findById(log1Id).orElseThrow();
        ActivityLog existingLog2 = activityLogRepo.findById(log2Id).orElseThrow();

        existingLog1.setUser(userB);
        existingLog2.setUser(userB);

        userB.addActivityLog(existingLog1);
        userB.addActivityLog(existingLog2);

        assertEquals(userB.getId(), existingLog1.getUser().getId());
        assertEquals(userB.getId(), existingLog2.getUser().getId());
        assertEquals(2, userB.getActivityLogs().size());
    }

    @Test
    void reassignActivityLogsFromOneUserToAnother_usingEntityManagerMerge_shouldSucceed() {
        User userA = createUser();

        ActivityLog log1 = new ActivityLog();
        log1.setAction("Login");
        log1.setUser(userA);

        ActivityLog log2 = new ActivityLog();
        log2.setAction("Completed Lesson");
        log2.setUser(userA);

        userA.addActivityLog(log1);
        userA.addActivityLog(log2);

        userA = userRepo.saveAndFlush(userA);

        Long log1Id = userA.getActivityLogs().get(0).getId();
        Long log2Id = userA.getActivityLogs().get(1).getId();

        User userB = new User();
        userB.setUserName("userB");
        userB.setFirstName("User");
        userB.setLastName("B");
        userB.setEmail("userB@example.com");
        userB.setRole(Role.STUDENT);
        userB.setPassword("passwordB");
        userB.setLastLogin(LocalDateTime.now());

        ActivityLog existingLog1 = activityLogRepo.findById(log1Id).orElseThrow();
        ActivityLog existingLog2 = activityLogRepo.findById(log2Id).orElseThrow();

        existingLog1.setUser(userB);
        existingLog2.setUser(userB);

        userB.addActivityLog(existingLog1);
        userB.addActivityLog(existingLog2);

        User mergedUserB = entityManager.merge(userB);
        entityManager.flush();

        assertNotNull(mergedUserB.getId());
        assertEquals(2, mergedUserB.getActivityLogs().size());
    }

    /*
        8. Save Child without Parent - using the same 3 approaches
     */
    @Test
    void saveActivityLogWithoutUser_usingSpringDataSave_shouldThrowException() {
        ActivityLog log = new ActivityLog();
        log.setAction("Action without user");

        assertThrows(DataIntegrityViolationException.class, () -> {
            activityLogRepo.saveAndFlush(log);
        });
    }

    @Test
    void saveActivityLogWithoutUser_usingEMPersist_shouldThrowException() {
        ActivityLog log = new ActivityLog();
        log.setAction("Action without user");

        assertThrows(PersistenceException.class, () -> {
            entityManager.persist(log);
            entityManager.flush();
        });
    }

    @Test
    void saveActivityLogWithoutUser_usingEMMerge_shouldThrowException() {
        ActivityLog log = new ActivityLog();
        log.setAction("Action without user");

        assertThrows(PersistenceException.class, () -> {
            entityManager.merge(log);
            entityManager.flush();
        });
    }

    /*
        9. Save Child with Parent initialized, but not present in the database - using the same 3 approaches
     */
    @Test
    void saveActivityLogWithTransientUser_usingPersist_shouldFail() {
        User transientUser = new User();
        transientUser.setUserName("newUser");
        transientUser.setEmail("new@example.com");
        transientUser.setPassword("pass");
        transientUser.setRole(Role.STUDENT);
        transientUser.setLastLogin(LocalDateTime.now());

        ActivityLog log = new ActivityLog();
        log.setAction("Login");
        log.setUser(transientUser);

        assertThrows(IllegalStateException.class, () -> {
            entityManager.persist(log);
            entityManager.flush();
        });
    }

    @Test
    void saveActivityLogWithTransientUser_usingMerge_shouldFail() {
        User transientUser = new User();
        transientUser.setUserName("newUser");
        transientUser.setEmail("new@example.com");
        transientUser.setPassword("pass");
        transientUser.setRole(Role.STUDENT);
        transientUser.setLastLogin(LocalDateTime.now());

        ActivityLog log = new ActivityLog();
        log.setAction("Login");
        log.setUser(transientUser);

        assertThrows(IllegalStateException.class, () -> {
            entityManager.merge(log);
            entityManager.flush();
        });
    }

    @Test
    void saveActivityLogWithTransientUser_usingRepoSave_shouldFail() {
        User transientUser = new User();
        transientUser.setUserName("newUser");
        transientUser.setEmail("new@example.com");
        transientUser.setPassword("pass");
        transientUser.setRole(Role.STUDENT);
        transientUser.setLastLogin(LocalDateTime.now());

        ActivityLog log = new ActivityLog();
        log.setAction("Login");
        log.setUser(transientUser);

        assertThrows(InvalidDataAccessApiUsageException.class, () -> {
            activityLogRepo.save(log);
        });
    }

    /*
       10. Save Child with Parent initialized, present in the database, but detached from EntityManager/Session - using the same 3 approaches
     */
    @Test
    void persistChildWithDetachedParent_shouldSucceed() {
        User savedUser = createUser();
        userRepo.saveAndFlush(savedUser);

        entityManager.detach(savedUser); // detach the parent

        ActivityLog log = new ActivityLog();
        log.setAction("Action 1");
        log.setUser(savedUser); // detached parent

        entityManager.persist(log);
        entityManager.flush();

        assertNotNull(log.getId(), "ActivityLog should have been persisted and have an ID");

        ActivityLog persistedLog = entityManager.find(ActivityLog.class, log.getId());
        assertNotNull(persistedLog, "Persisted ActivityLog should be found");

        assertEquals(savedUser.getId(), persistedLog.getUser().getId(), "User ID should match");

        assertFalse(entityManager.contains(savedUser), "User should still be detached");
    }


    @Test
    void mergeChildWithDetachedParent_shouldSucceed() {
        User savedUser = createUser();
        userRepo.saveAndFlush(savedUser);

        entityManager.detach(savedUser);

        ActivityLog log = new ActivityLog();
        log.setAction("Action 2");
        log.setUser(savedUser);

        ActivityLog mergedLog = entityManager.merge(log);
        entityManager.flush();

        assertNotNull(mergedLog.getId(), "Merged ActivityLog should have been persisted and have an ID");

        ActivityLog persistedLog = entityManager.find(ActivityLog.class, mergedLog.getId());
        assertNotNull(persistedLog, "Persisted ActivityLog should be found");

        assertEquals(savedUser.getId(), persistedLog.getUser().getId(), "User ID should match");

        assertFalse(entityManager.contains(savedUser), "Original User should still be detached");
    }

    @Test
    void repoSaveChildWithDetachedParent_shouldSucceed() {
        User savedUser = createUser();
        userRepo.saveAndFlush(savedUser);

        entityManager.detach(savedUser);

        ActivityLog log = new ActivityLog();
        log.setAction("Action 3");
        log.setUser(savedUser);

        ActivityLog savedLog = activityLogRepo.saveAndFlush(log);

        assertNotNull(savedLog.getId(), "Saved ActivityLog should have been persisted and have an ID");

        ActivityLog persistedLog = entityManager.find(ActivityLog.class, savedLog.getId());
        assertNotNull(persistedLog, "Persisted ActivityLog should be found");

        assertEquals(savedUser.getId(), persistedLog.getUser().getId(), "User ID should match");

        assertFalse(entityManager.contains(savedUser), "Original User should still be detached");
    }

    /*
        11. Fetch the Parent with JpaRepository, try changing it and don’t save it explicitly. Flush the session and check whether the changes were propagated to the database
     */
    @Test
    void modifyingManagedEntity_shouldBePersistedOnFlush() {
        User savedUser = createUser();
        userRepo.saveAndFlush(savedUser);

        User fetchedUser = userRepo.findById(savedUser.getId())
                .orElseThrow();

        fetchedUser.setEmail("changedEmail@gmail.com");

        entityManager.flush();

        entityManager.clear();

        User reloadedUser = userRepo.findById(savedUser.getId()).orElseThrow();

        assertEquals("changedEmail@gmail.com", reloadedUser.getEmail(), "Email should be updated in DB without explicit save");
    }
}
